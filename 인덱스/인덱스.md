## ***INDEX***
  
대표적으로 B-Tree 인덱스와 Hash 인덱스로 구분할 수 있다.  

- B-Tree 인덱스
컬럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘.  
- Hash 인덱스  
컬럼의 값으로 해시값을 계산해서 인덱싱하는 알고리즘으로, 매우 빠른 검색을 지원한다.  
값을 변형해서 인덱싱 하기 때문에 전방일치와 같이 값의 일부만 검색하거나 범위를 검색할 때는 해시 인덱스를 사용할 수 없다.  



  
##### `B-Tree 인덱스`  
컬럼의 값을 변형하지 않고 인덱스 구조체 내에서는 항상 정렬된 상태로 유지한다.  
루트 노드 - 브랜치 노드 - 리프 노드 형태이다.  

`인덱스 키 추가`  
저장될 키 값을 이용해 B-Tree 상의 적절한 위치를 검색한다.  
저장될 위치가 결정되면 레코드의 키 값과 대상 레코드의 주소 정보를 리프 노드에 저장한다.  
리프 노드가 꽉 차서 더는 저장할 수 없을 때 리프 노드가 분리 되어야 한다.  
이러한 작업 탓에 상대적으로 쓰기 작업에 비용이 많이 든다.  

`인덱스 키 삭제`  
해당 키 값이 저장된 리프노드를 찾아서 그냥 삭제 마크만 하면 작업이 완료된다.  

`인덱스 키 변경`  
인덱스 키 값은 그 값에 따라 저장될 리프 노드의 위치가 결정되므로 B-Tree의 키 값이 변경되는 경우 인덱스상의 키 값만 변경하는 것은 불가능하다.  
키 값을 삭제한 후, 다시 새로운 키 값을 추가하는 형태로 처리된다.  

`인덱스 키 검색`  
인덱스의 검색이란 루트 노드부터 시작해 브랜치 노드를 거쳐 최종 리프 노드 까지 이동하면서 비교 작업을 수행하는데,  
이를 "트리 탐색" 이라고 한다.  
B-Tree 인덱스를 이용한 검색은 100% 일치 또는 값을 앞 부분만 일치하는 경우에 사용할 수 있다.  
부등호 비교 조건에서도 인덱스를 활용할 수 있지만, 인덱스를 구성하는 키 값의 뒷부분만 검색하는 용도로는 인덱스를 사용할 수 없다.  

`인덱스 키 값의 크기`  
디스크에 데이터를 저장하는 가장 기본 단위를 페이지 또는 블록이라고 하며, 디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위가 된다.  
인덱스는 페이지 단위로 관리된다.  
노드를 구분하는 기준이 페이지 단위이다.  
MySQL의 B-Tree는 자식 노드의 갯수가 인덱스의 페이지 크기와 키 값의 크기에 따라 결정된다.    
인덱스를 구성하는 키 값의 크기가 커지면 디스크로부터 읽어야 하는 횟수가 늘어날 수 있다. (기본 16KB)  

`B-Tree 깊이`  
B-Tree의 깊이는 값을 검색할 때 몇 번이나 랜덤하게 디스크를 읽어야 하는지와 직결되는 문제다.  

`선택도`  
인덱스에서 선택도 혹은 기수성은 모든 인덱스 키 값 가운데 유니크한 값의 수를 의미한다.  
선택도가 높을수록 검색 대상이 줄어들기 때문에 그만큼 빠르게 처리된다.  

`읽어야 하는 레코드의 건수`  
인덱스를 통해 읽어야 할 레코드의 건수가 전체 테이블 레코드의 20~25%를 넘어서면 인덱스를 이용하지 않고 테이블을 모두 직접 읽어서 필요한 레코드만 가려내는 방식으로 처리하는 것이 효율적이다.  

`B-Tree를 통한 데이터 읽기`  
어떤 경우에 인덱스를 사용하게 유도할지, 하용하지 못하게 할지 판단하려면 MySQL이 인덱스를 이용하는 대표적인 방법 세가지를 알아야 한다.  

`인덱스 레인지 스캔`  
인덱스 레인지 스캔은 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식이다.  
일단 시작해야 할 위치를 찾으면 그때부터는 리프 노드의 레코드만 순서대로 읽으면 된다.  
루트와 브랜치 노드를 이용해 스캔 시작 위치를 검색하고, 그 지점부터 필요한 방향(오름 or 내림차순)으로 인덱스를 읽어 나가는 과정이다.  
어떤 방식이던, 컬럼의 정순 혹은 역순으로 데이터를 가져온다는게 중요하다.  
스캔한 레코드 한건 한건 단위로 랜덤 I/O가 한 번씩 일어난다.  
I/O 과정은 데이터에 따라 필요하지 않을 수 있는데, 이를 커버링 인덱스라고 한다.  












